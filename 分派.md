# 分派调用

今天讲一下分派调用，首先，分派调用是一种方法调用形式，它可能为静态的，也可能为动态的，还可分为单分派和多分派。

之所以讲分派调用，是因为其过程将会揭示多态性特征的一些最基本的体现，比如大家关心的“重载”和“重写”。

## 静态分派--方法重载

首先看一段面试代码：

    public class StaticDispatch {

    static abstract class Human{}

    static class Man extends Human{}

    static class Woman extends Human{}

    public void sayHello(Human guy){
        System.out.println("Hello, guy!");
    }

    public void sayHello(Man guy){
        System.out.println("Hello, gentleman!");
    }

    public void sayHello(Woman guy){
        System.out.println("Hello, lady!");
    }

    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        StaticDispatch sd = new StaticDispatch();
        sd.sayHello(man);
        sd.sayHello(woman);
        }
    }
此程序的输出结果如下：

    Hello, guy!
    Hello, guy!
为什么虚拟机会选择执行参数类型为Human的重载版本呢？先看下面这行代码：

    Human man = new Man();

在以上代码中，我们称“Human”为变量man的“静态类型”，或者叫“外观类型”，后面的“Man”称为变量的“实际类型”或者叫“运行时类型”。

两者最重要的区别在于：

1. 最终的静态类型是在编译期可知的；
2. 实际类型在运行时才可确定，编译期并不知道一个对象的实际类型。

在代码中，man和woman的静态类型相同，而实际类型却不同。但是虚拟机（准确的说是编译器）在重载时是**通过参数的静态类型而不是实际类型**作为判定依据的。

> 所有依赖静态类型来决定方法执行版本的分派动作，被称为**静态分派**。静态分派的最典型应用表现就是**方法重载**。

静态分派发生在编译阶段。因此确定静态分派动作的是编译器，而非虚拟机。

## 重载方法-选择相对适合版本

再看一段代码：

    public class OverLoad {
    public static void sayHello(Object arg) {
        System.out.println("hello object");
    }

    public static void sayHello(int arg) {
        System.out.println("hello int");
    }

    public static void sayHello(long arg) {
        System.out.println("hello long");
    }

    public static void sayHello(Character arg) {
        System.out.println("hello character");
    }

    public static void sayHello(char arg) {
        System.out.println("hello char");
    }

    public static void sayHello(char... arg) {
        System.out.println("hello char...");
    }

    public static void sayHello(Serializable arg) {
        System.out.println("hello Serializable");
    }

    public static void main(String[] args) {
        sayHello('a');
    }
    }
上面的代码运行后会输出：

    hello char

这很好理解，因为'a'是char类型数据，现在注释掉sayHello(char arg)方法，输出变为：

    hello int

这里发生了一次自动类型转换，因为'a'还可以表示数字97（Unicode数值），现在注释掉sayHello(int arg)，输出变为：

    hello long

这里发生了两次自动类型转换，整数97转型为长整数97L，现在注释掉sayHello(long arg)，输出变为：

    hello character

这时发生了一次自动装箱，'a'被包装为它的封装类型Character，继续注释掉sayHello(Character arg)，输出变为：

    hello Serializable

这是因为Serializable是Character实现的一个接口，'a'自动装箱后发现没有装箱类，但是找到了装箱类实现的接口，所以发生了一次自动转型。

注意，当出现两个优先级一样的参数的重载方法时，编译器无法确定要转型为哪种类型，因此提示类型模糊，并拒绝编译。下面继续注释掉sayHello(Serializable arg)，输出会变为：

    hello object

这时是char装箱后转型为父类，如果有多个父类，那将在继承关系中从下往上开始搜索，越接上层的优先级越低，最后注释掉sayHello(Object arg)，输出会变为：

    hello char...

可见变长参数的重载优先级是最低的。
